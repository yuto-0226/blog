<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>資料結構 on Yuto's notes</title><link>https://example.org/tags/%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B/</link><description>Recent content in 資料結構 on Yuto's notes</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>2023 © [Yuto](https://joeroe.io)</copyright><lastBuildDate>Sun, 13 Nov 2022 20:21:16 +0000</lastBuildDate><atom:link href="https://example.org/tags/%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B/index.xml" rel="self" type="application/rss+xml"/><item><title>[C++]線段樹</title><link>https://example.org/posts/csie/dsa/segment-tree/</link><pubDate>Sun, 13 Nov 2022 20:21:16 +0000</pubDate><guid>https://example.org/posts/csie/dsa/segment-tree/</guid><description>程式碼 #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; class Node{ public: int start; int end; int max; int min; int sum; Node *left=nullptr; Node *right=nullptr; Node(int start,int end,int max,int min,int sum,Node *left=nullptr,Node *right=nullptr): start(start),end(end),max(max),min(min),sum(sum),left(left),right(right){} }; Node *build(int start,int end,int val[]){ if(start==end){ //cout&amp;lt;&amp;lt;&amp;#34;build: [&amp;#34;&amp;lt;&amp;lt;start&amp;lt;&amp;lt;&amp;#34;, &amp;#34;&amp;lt;&amp;lt;end&amp;lt;&amp;lt;&amp;#34;] node-&amp;gt;,max,min,sum=&amp;#34;&amp;lt;&amp;lt;val[start]&amp;lt;&amp;lt;&amp;#34;\n&amp;#34;; return new Node(start,end,val[start],val[start],val[start],nullptr,nullptr); } int mid=(start+end)/2; Node *left=build(start,mid,val); Node *right=build(mid+1,end,val); //cout&amp;lt;&amp;lt;&amp;#34;build: [&amp;#34;&amp;lt;&amp;lt;start&amp;lt;&amp;lt;&amp;#34;, &amp;#34;&amp;lt;&amp;lt;end&amp;lt;&amp;lt;&amp;#34;]&amp;#34;&amp;lt;&amp;lt;&amp;#34; node-&amp;gt;max=&amp;#34;&amp;lt;&amp;lt;max(left-&amp;gt;max,right-&amp;gt;max)&amp;lt;&amp;lt;&amp;#34; node-&amp;gt;min=&amp;#34;&amp;lt;&amp;lt;min(left-&amp;gt;min,right-&amp;gt;min)&amp;lt;&amp;lt;&amp;#34; node-&amp;gt;sum=&amp;#34;&amp;lt;&amp;lt;left-&amp;gt;sum+right-&amp;gt;sum&amp;lt;&amp;lt;&amp;#34;\n&amp;#34;; return new Node(start,end,max(left-&amp;gt;max,right-&amp;gt;max),min(left-&amp;gt;min,right-&amp;gt;min),left-&amp;gt;sum+right-&amp;gt;sum,left,right); } int query_sum(Node *root,int i,int j){ int sum=0; //cout&amp;lt;&amp;lt;&amp;#34;query: [&amp;#34;&amp;lt;&amp;lt;i&amp;lt;&amp;lt;&amp;#34;, &amp;#34;&amp;lt;&amp;lt;j&amp;lt;&amp;lt;&amp;#34;] @ [&amp;#34;&amp;lt;&amp;lt;root-&amp;gt;start&amp;lt;&amp;lt;&amp;#34;, &amp;#34;&amp;lt;&amp;lt;root-&amp;gt;end&amp;lt;&amp;lt;&amp;#34;] root-&amp;gt;sum=&amp;#34;&amp;lt;&amp;lt;root-&amp;gt;sum&amp;lt;&amp;lt;&amp;#34;\n&amp;#34;; if(root-&amp;gt;start==root-&amp;gt;end) return root-&amp;gt;sum; if(root-&amp;gt;start==i&amp;amp;&amp;amp;root-&amp;gt;end==j) return root-&amp;gt;sum; int mid=root-&amp;gt;start+(root-&amp;gt;end-root-&amp;gt;start)/2; if(j&amp;lt;=mid) return query_sum(root-&amp;gt;left,i,j); else if(i&amp;gt;mid) return query_sum(root-&amp;gt;right,i,j); else return query_sum(root-&amp;gt;left,i,mid)+query_sum(root-&amp;gt;right,mid+1,j); } int query_max(Node *root,int i,int j){ int sum=0; //cout&amp;lt;&amp;lt;&amp;#34;query: [&amp;#34;&amp;lt;&amp;lt;i&amp;lt;&amp;lt;&amp;#34;, &amp;#34;&amp;lt;&amp;lt;j&amp;lt;&amp;lt;&amp;#34;] @ [&amp;#34;&amp;lt;&amp;lt;root-&amp;gt;start&amp;lt;&amp;lt;&amp;#34;, &amp;#34;&amp;lt;&amp;lt;root-&amp;gt;end&amp;lt;&amp;lt;&amp;#34;] root-&amp;gt;max=&amp;#34;&amp;lt;&amp;lt;root-&amp;gt;max&amp;lt;&amp;lt;&amp;#34;\n&amp;#34;; if(root-&amp;gt;start==root-&amp;gt;end) return root-&amp;gt;max; if(root-&amp;gt;start==i&amp;amp;&amp;amp;root-&amp;gt;end==j) return root-&amp;gt;max; int mid=root-&amp;gt;start+(root-&amp;gt;end-root-&amp;gt;start)/2; if(j&amp;lt;=mid) return query_max(root-&amp;gt;left,i,j); else if(i&amp;gt;mid) return query_max(root-&amp;gt;right,i,j); else return max(query_max(root-&amp;gt;left,i,mid),query_max(root-&amp;gt;right,mid+1,j)); } int query_min(Node *root,int i,int j){ int sum=0; //cout&amp;lt;&amp;lt;&amp;#34;query: [&amp;#34;&amp;lt;&amp;lt;i&amp;lt;&amp;lt;&amp;#34;, &amp;#34;&amp;lt;&amp;lt;j&amp;lt;&amp;lt;&amp;#34;] @ [&amp;#34;&amp;lt;&amp;lt;root-&amp;gt;start&amp;lt;&amp;lt;&amp;#34;, &amp;#34;&amp;lt;&amp;lt;root-&amp;gt;end&amp;lt;&amp;lt;&amp;#34;] root-&amp;gt;min=&amp;#34;&amp;lt;&amp;lt;root-&amp;gt;min&amp;lt;&amp;lt;&amp;#34;\n&amp;#34;; if(root-&amp;gt;start==root-&amp;gt;end) return root-&amp;gt;min; if(root-&amp;gt;start==i&amp;amp;&amp;amp;root-&amp;gt;end==j) return root-&amp;gt;min; int mid=root-&amp;gt;start+(root-&amp;gt;end-root-&amp;gt;start)/2; if(j&amp;lt;=mid) return query_min(root-&amp;gt;left,i,j); else if(i&amp;gt;mid) return query_min(root-&amp;gt;right,i,j); else return min(query_min(root-&amp;gt;left,i,mid),query_min(root-&amp;gt;right,mid+1,j)); }</description></item><item><title>[C++]BIT 樹狀樹組</title><link>https://example.org/posts/csie/dsa/bit/</link><pubDate>Fri, 01 Apr 2022 11:52:00 +0000</pubDate><guid>https://example.org/posts/csie/dsa/bit/</guid><description>BIT A Fenwick tree or binary indexed tree is a data structure that can efficiently update elements and calculate prefix sums in a table of numbers. -wiki
樹狀數組也稱作 Fenwick Tree 或 Binary Indexed Tree(BIT)，用來儲存資料，且可以快速求出前綴和或區間加總。對於一個長度 n 的陣列，可以在 O(n) 的時間初始化，在 O(n) 時間詢問一個前綴的訊息例如前綴和，以及在 O(n) 的時間修改其中一個值。但是 BIT 的缺點就是有些問題無法轉為前綴間的運算，無法個別操作元素。
由上面這張圖可了解 BIT 儲存的區間。Index[] 為儲存資料的陣列，BIT[] 為實際上儲存的區間。
通常一個數狀數組會有 3 個函式:
uptade(idx,delta): 將 delta 加到 idx 的節點上 query(index): 查詢從第一個位置到 idx 的所有節點的加總 range_query(idx_this,idx_that): 查詢從 idx_this 到 idx_that 間所有節點的總和 lowbit() lowbit 是為了求一個二進位數中最低位1的值(最靠近右邊的 1 的值)，構成 BIT 的核心</description></item><item><title>[C++]鏈接串列 Linked List</title><link>https://example.org/posts/csie/dsa/cpp-linkedlist/</link><pubDate>Sat, 01 Jan 2022 21:00:11 +0000</pubDate><guid>https://example.org/posts/csie/dsa/cpp-linkedlist/</guid><description>簡介 何謂鏈接串列(Linked List)?串列是一種常見的資料結構， 使用節點儲存資料，且透過接點的指標指向下一個節點， 形成一串記憶體位置不相連的資料串。
Linked List vs Array Array Pros
random access：只要利用index即可在O(1)時間對Array的資料做存取。 較Linked list為節省記憶體空間：因為Linked list需要多一個pointer來記錄下一個節點的記憶體位置。 Cons
新增/刪除資料很麻煩：若要在第一個位置新增資料，就需要O(N)時間把矩陣中所有元素往後移動。同理，若要刪除第一個位置的資料，也需要O(N)時間把矩陣中剩餘的元素往前移動。 若資料數量時常在改變，要時常調整矩陣的大小，會花費O(N)的時間在搬動資料(把資料從舊的矩陣移動到新的矩陣)。 適用時機
希望能夠快速存取資料。 已知欲處理的資料數量，便能確認矩陣的大小。 要求記憶體空間的使用越少越好。 Linked List Pros
新增/刪除資料較Array簡單，只要對O(1)個節點調整pointer即可，不需要如同Array般搬動其餘元素。 Linked list的資料數量可以是動態的，不像Array會有resize的問題。 Cons
因為Linked list沒有index，若要找到特定節點，需要從頭(Node *first)開始找起，搜尋的時間複雜度為O(N)。 需要額外的記憶體空間來儲存pointer。 適用時機
無法預期資料數量時，使用Linked list就沒有resize的問題。 需要頻繁地新增/刪除資料時。 不需要快速查詢資料。 用 class 實作 #include &amp;lt;bits/stdc++.h&amp;gt; using std::cout; using std::endl; class Linkedlist; class Node{ private: int data; Node *next; public: Node():data(0),next(0){}; Node(int x):data(x),next(0){}; friend class LinkedList; }; class LinkedList{ private: Node *first; public: LinkedList():first(0){}; void printlist(); void push_front(int x); void push_back(int x); void erase(int x); void clear(); void reverse(); }; void LinkedList::printlist(){ if(first==0){ cout&amp;lt;&amp;lt;&amp;#34;List is empty.</description></item></channel></rss>