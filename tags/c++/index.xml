<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>C++ on Yuto's notes</title><link>https://example.org/tags/c++/</link><description>Recent content in C++ on Yuto's notes</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>2023 © [Yuto](https://joeroe.io)</copyright><lastBuildDate>Fri, 18 Nov 2022 20:57:16 +0000</lastBuildDate><atom:link href="https://example.org/tags/c++/index.xml" rel="self" type="application/rss+xml"/><item><title>0.教材說明與預備知識</title><link>https://example.org/posts/csie/ap325/0/</link><pubDate>Fri, 18 Nov 2022 20:57:16 +0000</pubDate><guid>https://example.org/posts/csie/ap325/0/</guid><description>0.2.1 基本C++模板與輸入輸出 #include &amp;lt;bits/stdc++.h&amp;gt; // 萬用標頭檔 using namespace std; int main(){ ios::sync_with_stdio(0); // 優化cin的東西 cin.tie(0); // code here return 0; } 有優化cin的那兩行就不能再把cin/cout與scanf/printf混用，不然會發生無法預測的錯誤
使用scanf/printf 使用cin/cout並優化 0.2.2 程式測試與測試資料 stdin: 標準輸入裝置，預設鍵盤 stdout: 標準輸出裝置，預設螢幕 stderr: 標準錯誤紀錄裝置，預設螢幕 unix環境下的IO重導:
./a.out &amp;lt;test.in &amp;gt;test.out 程式裡面I/O重導:
freopen(&amp;#34;test.in&amp;#34;,&amp;#34;r&amp;#34;,stdin); freopen(&amp;#34;test.out&amp;#34;,&amp;#34;w&amp;#34;,stdout); unix環境下計時:
time a.out &amp;lt;test.in 程式裡面計時:
#include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; int main(){ clock_t start,end; start=clock(); // code here end=clock(); fprint(stderr,&amp;#34;time from start to end = %f sec.\n&amp;#34;,(float)(end-start)/CLOCKS_PER_SEC); return 0; } 0.2.3 複雜度估算 複雜度估算方式 時間複雜度通常以$O(f(n))$來表示，念作big-O，以n來表示資料量，常數倍通常忽略不計 常見的有:$O(n)$、$O(nlog(n))$、$(n^2)$</description></item><item><title>[C++]線段樹</title><link>https://example.org/posts/csie/dsa/segment-tree/</link><pubDate>Sun, 13 Nov 2022 20:21:16 +0000</pubDate><guid>https://example.org/posts/csie/dsa/segment-tree/</guid><description>程式碼 #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; class Node{ public: int start; int end; int max; int min; int sum; Node *left=nullptr; Node *right=nullptr; Node(int start,int end,int max,int min,int sum,Node *left=nullptr,Node *right=nullptr): start(start),end(end),max(max),min(min),sum(sum),left(left),right(right){} }; Node *build(int start,int end,int val[]){ if(start==end){ //cout&amp;lt;&amp;lt;&amp;#34;build: [&amp;#34;&amp;lt;&amp;lt;start&amp;lt;&amp;lt;&amp;#34;, &amp;#34;&amp;lt;&amp;lt;end&amp;lt;&amp;lt;&amp;#34;] node-&amp;gt;,max,min,sum=&amp;#34;&amp;lt;&amp;lt;val[start]&amp;lt;&amp;lt;&amp;#34;\n&amp;#34;; return new Node(start,end,val[start],val[start],val[start],nullptr,nullptr); } int mid=(start+end)/2; Node *left=build(start,mid,val); Node *right=build(mid+1,end,val); //cout&amp;lt;&amp;lt;&amp;#34;build: [&amp;#34;&amp;lt;&amp;lt;start&amp;lt;&amp;lt;&amp;#34;, &amp;#34;&amp;lt;&amp;lt;end&amp;lt;&amp;lt;&amp;#34;]&amp;#34;&amp;lt;&amp;lt;&amp;#34; node-&amp;gt;max=&amp;#34;&amp;lt;&amp;lt;max(left-&amp;gt;max,right-&amp;gt;max)&amp;lt;&amp;lt;&amp;#34; node-&amp;gt;min=&amp;#34;&amp;lt;&amp;lt;min(left-&amp;gt;min,right-&amp;gt;min)&amp;lt;&amp;lt;&amp;#34; node-&amp;gt;sum=&amp;#34;&amp;lt;&amp;lt;left-&amp;gt;sum+right-&amp;gt;sum&amp;lt;&amp;lt;&amp;#34;\n&amp;#34;; return new Node(start,end,max(left-&amp;gt;max,right-&amp;gt;max),min(left-&amp;gt;min,right-&amp;gt;min),left-&amp;gt;sum+right-&amp;gt;sum,left,right); } int query_sum(Node *root,int i,int j){ int sum=0; //cout&amp;lt;&amp;lt;&amp;#34;query: [&amp;#34;&amp;lt;&amp;lt;i&amp;lt;&amp;lt;&amp;#34;, &amp;#34;&amp;lt;&amp;lt;j&amp;lt;&amp;lt;&amp;#34;] @ [&amp;#34;&amp;lt;&amp;lt;root-&amp;gt;start&amp;lt;&amp;lt;&amp;#34;, &amp;#34;&amp;lt;&amp;lt;root-&amp;gt;end&amp;lt;&amp;lt;&amp;#34;] root-&amp;gt;sum=&amp;#34;&amp;lt;&amp;lt;root-&amp;gt;sum&amp;lt;&amp;lt;&amp;#34;\n&amp;#34;; if(root-&amp;gt;start==root-&amp;gt;end) return root-&amp;gt;sum; if(root-&amp;gt;start==i&amp;amp;&amp;amp;root-&amp;gt;end==j) return root-&amp;gt;sum; int mid=root-&amp;gt;start+(root-&amp;gt;end-root-&amp;gt;start)/2; if(j&amp;lt;=mid) return query_sum(root-&amp;gt;left,i,j); else if(i&amp;gt;mid) return query_sum(root-&amp;gt;right,i,j); else return query_sum(root-&amp;gt;left,i,mid)+query_sum(root-&amp;gt;right,mid+1,j); } int query_max(Node *root,int i,int j){ int sum=0; //cout&amp;lt;&amp;lt;&amp;#34;query: [&amp;#34;&amp;lt;&amp;lt;i&amp;lt;&amp;lt;&amp;#34;, &amp;#34;&amp;lt;&amp;lt;j&amp;lt;&amp;lt;&amp;#34;] @ [&amp;#34;&amp;lt;&amp;lt;root-&amp;gt;start&amp;lt;&amp;lt;&amp;#34;, &amp;#34;&amp;lt;&amp;lt;root-&amp;gt;end&amp;lt;&amp;lt;&amp;#34;] root-&amp;gt;max=&amp;#34;&amp;lt;&amp;lt;root-&amp;gt;max&amp;lt;&amp;lt;&amp;#34;\n&amp;#34;; if(root-&amp;gt;start==root-&amp;gt;end) return root-&amp;gt;max; if(root-&amp;gt;start==i&amp;amp;&amp;amp;root-&amp;gt;end==j) return root-&amp;gt;max; int mid=root-&amp;gt;start+(root-&amp;gt;end-root-&amp;gt;start)/2; if(j&amp;lt;=mid) return query_max(root-&amp;gt;left,i,j); else if(i&amp;gt;mid) return query_max(root-&amp;gt;right,i,j); else return max(query_max(root-&amp;gt;left,i,mid),query_max(root-&amp;gt;right,mid+1,j)); } int query_min(Node *root,int i,int j){ int sum=0; //cout&amp;lt;&amp;lt;&amp;#34;query: [&amp;#34;&amp;lt;&amp;lt;i&amp;lt;&amp;lt;&amp;#34;, &amp;#34;&amp;lt;&amp;lt;j&amp;lt;&amp;lt;&amp;#34;] @ [&amp;#34;&amp;lt;&amp;lt;root-&amp;gt;start&amp;lt;&amp;lt;&amp;#34;, &amp;#34;&amp;lt;&amp;lt;root-&amp;gt;end&amp;lt;&amp;lt;&amp;#34;] root-&amp;gt;min=&amp;#34;&amp;lt;&amp;lt;root-&amp;gt;min&amp;lt;&amp;lt;&amp;#34;\n&amp;#34;; if(root-&amp;gt;start==root-&amp;gt;end) return root-&amp;gt;min; if(root-&amp;gt;start==i&amp;amp;&amp;amp;root-&amp;gt;end==j) return root-&amp;gt;min; int mid=root-&amp;gt;start+(root-&amp;gt;end-root-&amp;gt;start)/2; if(j&amp;lt;=mid) return query_min(root-&amp;gt;left,i,j); else if(i&amp;gt;mid) return query_min(root-&amp;gt;right,i,j); else return min(query_min(root-&amp;gt;left,i,mid),query_min(root-&amp;gt;right,mid+1,j)); }</description></item><item><title>用 C++ 模擬簡單的 8-bit cpu</title><link>https://example.org/posts/csie/simple-8bit-cpu/</link><pubDate>Sat, 05 Nov 2022 23:13:30 +0000</pubDate><guid>https://example.org/posts/csie/simple-8bit-cpu/</guid><description>最近在看 beneater 的 8-bit cpu 想說用 C++ 寫看看練練手，所以就寫出來啦~ 由於還沒對 CPU 理解得很徹底，只有把ALU做出來而已，以後再看看會不會在重寫一個哈哈。
架構 accumulator register b register instruction register program counter 程式碼 #include&amp;lt;bits/stdc++.h&amp;gt; #include&amp;lt;stdio.h&amp;gt; using byte=uint8_t; byte accumulator; // accumulator register byte b; // register b byte instruction; // instruction register byte counter; // program counter bool negitive; // negitive flag bool sign; // sign flag bool HLT=0; byte memory[256]={0b11110000}; bool isDebug=0; void reset(){ accumulator=0; b=0; counter=0; instruction=0; for(int i=0;i&amp;lt;256;i++) memory[i]=0b11110000; } void fetch(){ if(HLT) return; instruction=memory[counter]; counter+=1; } void STA(){ if(isDebug) printf(&amp;#34;%#4x STA: %#x\n&amp;#34;,counter,memory[counter]); accumulator=memory[counter]; counter+=1; } void STB(){ if(isDebug) printf(&amp;#34;%#4x STB: %#x\n&amp;#34;,counter,memory[counter]); b=memory[counter]; counter+=1; } void ADD(){ if(isDebug) printf(&amp;#34;%#4x ADD: %#x\n&amp;#34;,counter,memory[counter]); b=memory[counter]; accumulator+=b; counter+=1; } void OUT(){ if(isDebug) printf(&amp;#34;%#4x OUT\n&amp;#34;,counter); printf(&amp;#34;%#4x\n&amp;#34;,accumulator); } void decode(){ instruction/=16; if(isDebug) printf(&amp;#34;%#4x instruction: %#x\n&amp;#34;,counter-1,instruction); switch(instruction){ case 0x0001: // STA STA(); break; case 0b0010: // LDA break; case 0b0011: // STB STB(); break; case 0b0100: // LDB break; case 0b0101: // ADD ADD(); break; case 0b1101: // OUT OUT(); break; case 0b1110: // HLT if(isDebug) printf(&amp;#34;%#4x HLT\n&amp;#34;,counter); HLT=1; break; case 0b1111: // NOP if(isDebug) printf(&amp;#34;%#4x NOP\n&amp;#34;,counter); break; } } void print_register(byte reg){ for(int i=0;i&amp;lt;8;i++){ printf(&amp;#34;%u&amp;#34;,reg/128); reg*=2; } } void print_memory(byte address){ for(int i=0;i&amp;lt;8;i++){ printf(&amp;#34;%u&amp;#34;,memory[address]/128); memory[address]*=2; } } void debug(){ if(!</description></item><item><title>[C++]感知機 PLA</title><link>https://example.org/posts/csie/dsa/perceptron/</link><pubDate>Thu, 12 May 2022 14:20:28 +0000</pubDate><guid>https://example.org/posts/csie/dsa/perceptron/</guid><description>感知機 PLA 針對線性資料的分類 訓練後 函式&amp;amp;變數 dot()，將兩向量(double)內積並回傳其值(double)。 double dot(std::vector&amp;lt;double&amp;gt; vec_1, std::vector&amp;lt;double&amp;gt; vec_2); vec_to_str()，將向量轉換成 string 並回傳。 std::string vec_to_str(std::vector&amp;lt;double&amp;gt; vec); intput_data()，輸入一組資料(輸入向量&amp;amp;類型) train_data intput_data(int dimension); class train_data class train_data{ private: std::vector&amp;lt;double&amp;gt; inputs; bool is_type; public: train_data(std::vector&amp;lt;double&amp;gt; inputs, bool is_type); std::vector&amp;lt;double&amp;gt; get_intputs(); bool get_type(); std::string to_str(); }; private 輸入層向量。 std::vector&amp;lt;double&amp;gt; inputs; 類型。 bool is_type; public 建構元，直接初始化輸入向量和類型。 train_data(std::vector&amp;lt;double&amp;gt; inputs, bool is_type); get_intputs()，回傳輸入層向量。 std::vector&amp;lt;double&amp;gt; get_intputs(); get_type()，回傳類型。 bool get_type(); to_str()，將 train_data 物件的輸入向量、類型轉換成字串回傳。 std::string to_str(); class perceptron class perceptron{ private: std::vector&amp;lt;train_data&amp;gt; data; std::vector&amp;lt;double&amp;gt; weights; double bias; double learning_rate; void init_weights(); void init_bias(); double cost(train_data data); void update(train_data data); void train_epoch(); public: perceptron(std::vector&amp;lt;train_data&amp;gt; data, double learning_rate); bool predict_type(train_data data); void train(int epochs,bool reset); std::string to_str(); }; private data，訓練資料陣列。 std::vector&amp;lt;train_data&amp;gt; data; weights，權重向量。 std::vector&amp;lt;double&amp;gt; weights; bias，偏置值(閥值)。 double bias; learning_rate，學習率。 double learning_rate; init_weights()，初始化權重向量。 void init_weights(); init_bias，初始化偏置值。 void init_bias(); cost()，回傳 cost double cost(train_data data); update()，更新權重。 void update(train_data data); train_epoch()，訓練完一組資料。 void train_epoch(); public 建構元，設定輸入向量陣列、學習率。 perceptron(std::vector&amp;lt;train_data&amp;gt; data, double learning_rate); predict_type()，感知姬預測的類型 bool predict_type(train_data data); train()，訓練感知機。 void train(int epochs,bool reset); to_str()，把權重、偏置值及學習率轉換成字串後回傳。 std::string to_str(); 預設資料集 int main(){ std::vector&amp;lt;train_data&amp;gt; data; int n_data=20; int n_dimension=0; double learning_rate=0; double n_correct=0; int n_epoch=0; clock_t start,end; for(size_t i=0;i&amp;lt;n_data;i++){ data.</description></item><item><title>[C++]BIT 樹狀樹組</title><link>https://example.org/posts/csie/dsa/bit/</link><pubDate>Fri, 01 Apr 2022 11:52:00 +0000</pubDate><guid>https://example.org/posts/csie/dsa/bit/</guid><description>BIT A Fenwick tree or binary indexed tree is a data structure that can efficiently update elements and calculate prefix sums in a table of numbers. -wiki
樹狀數組也稱作 Fenwick Tree 或 Binary Indexed Tree(BIT)，用來儲存資料，且可以快速求出前綴和或區間加總。對於一個長度 n 的陣列，可以在 O(n) 的時間初始化，在 O(n) 時間詢問一個前綴的訊息例如前綴和，以及在 O(n) 的時間修改其中一個值。但是 BIT 的缺點就是有些問題無法轉為前綴間的運算，無法個別操作元素。
由上面這張圖可了解 BIT 儲存的區間。Index[] 為儲存資料的陣列，BIT[] 為實際上儲存的區間。
通常一個數狀數組會有 3 個函式:
uptade(idx,delta): 將 delta 加到 idx 的節點上 query(index): 查詢從第一個位置到 idx 的所有節點的加總 range_query(idx_this,idx_that): 查詢從 idx_this 到 idx_that 間所有節點的總和 lowbit() lowbit 是為了求一個二進位數中最低位1的值(最靠近右邊的 1 的值)，構成 BIT 的核心</description></item><item><title>[LeetCode] 69. Sqrt(x)(C++)</title><link>https://example.org/posts/sol/sqrtx/</link><pubDate>Fri, 04 Mar 2022 19:50:42 +0000</pubDate><guid>https://example.org/posts/sol/sqrtx/</guid><description>題目 Given a non-negative integer x, compute and return the square root of x.
Since the return type is an integer, the decimal digits are truncated, and only the integer part of the result is returned.
Note: You are not allowed to use any built-in exponent function or operator, such as pow(x, 0.5) or x ** 0.5.
Example 1:
Input: x = 4 Output: 2 Example 2:
Input: x = 8 Output: 2 Explanation: The square root of 8 is 2.</description></item><item><title>[LeetCode] 1. Two-Sum(C++)</title><link>https://example.org/posts/sol/two-sum/</link><pubDate>Fri, 04 Mar 2022 19:32:42 +0000</pubDate><guid>https://example.org/posts/sol/two-sum/</guid><description>題目 Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.
You may assume that each input would have exactly one solution, and you may not use the same element twice.
You can return the answer in any order.
Example 1:
Input: nums = [2,7,11,15], target = 9 Output: [0,1] Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].</description></item><item><title>[C++]泛洪演算法 Flood Fill Alogrithm</title><link>https://example.org/posts/csie/dsa/floodfill/</link><pubDate>Sat, 05 Feb 2022 14:29:02 +0000</pubDate><guid>https://example.org/posts/csie/dsa/floodfill/</guid><description>簡介 Flood Fill 演算法是從一個區域中提取若干個連通的點與其他相鄰區域區分開(或分別染成不同顏色)的經典演算法(Algorithm)。因為其思路類似洪水從一個區域擴散到所有能到達的區域而得名。
實作方法 深度優先搜尋(Depth-First Search,DFS) 廣度優先搜尋(Breadth-First Search,BFS) BFS 實作 把最外面的點加入佇列(Queue)裡面，分別按照佇列中的點染色
// title: flood fill algorithm // date: 2/1 // author: 羅崧瑋 #include&amp;lt;bits/stdc++.h&amp;gt; #include&amp;lt;unistd.h&amp;gt; // terminal color font using namespace std; // matrix size #define row 10 #define col 10 // 上,下,左,右 int nx[4]={0,1,0,-1}; int ny[4]={1,0,-1,0}; // pair type typedef struct pair{ int x; int y; }pair_t; void printa(int a[row][col]); // (i,j) 起始位置 void floodfill(int a[row][col],int i,int j,int newc){ // 染色佇列 queue&amp;lt;pair_t&amp;gt; pos; pos.</description></item><item><title>向量 Vector(STL)</title><link>https://example.org/posts/csie/c++/cpp-vector/</link><pubDate>Wed, 05 Jan 2022 20:24:37 +0000</pubDate><guid>https://example.org/posts/csie/c++/cpp-vector/</guid><description>前言 在學寫C++的過程當中，從 Array 到 Vector 一直是很難跨越的障礙， 因為我的物件導向和指標不是學的很完善，導致會有點看不懂程式碼在做什麼， 所以這次我透過邊實作邊學習的方式來盡量彌補我知識上的不足， 順便做個筆記來記錄。
簡介 Vector 是 C++ 標準程式庫中的一個 class，可視為會自動擴展容量的陣列， 是C++標準程式庫中的眾多容器(container)之一，以循序(Sequential)的方式維護變數集合， 使用前預先 #include &amp;lt;vector&amp;gt; 即可。
特色 支援隨機存取 集合尾端增刪元素很快 : 常數時間 O(1) 集合中間增刪元素比較費時 : 線性時間 O(n) 以模板(泛型)方式實現，可以儲存任意類型的變數，包括使用者自定義的資料型態。 成員函式 vector 類別是以容器(Container)模式為基準設計的，也就是說，基本上它有 begin()、end()、size()、max_size()、empty() 以及 swap() 這幾個方法。
存取元素的方法 v[i] : 存取索引值為 i 的元素值 (索引值從零起算，故第一個元素是v[0]。) v.at(i) : 存取索引值為 i 的元素的值 v.front() : 回傳 vector 第一個元素的值 v.back() : 回傳 vector 最尾端元素的值 用 operator [] 可能會 Segmentation Fault。以 at() 存取會做陣列邊界檢查，如果存取越界將會拋出一個例外，這是與 operator [] 的唯一差異。撰寫較嚴肅、安全性較高的程式時使用 at()。</description></item><item><title>[C++]鏈接串列 Linked List</title><link>https://example.org/posts/csie/dsa/cpp-linkedlist/</link><pubDate>Sat, 01 Jan 2022 21:00:11 +0000</pubDate><guid>https://example.org/posts/csie/dsa/cpp-linkedlist/</guid><description>簡介 何謂鏈接串列(Linked List)?串列是一種常見的資料結構， 使用節點儲存資料，且透過接點的指標指向下一個節點， 形成一串記憶體位置不相連的資料串。
Linked List vs Array Array Pros
random access：只要利用index即可在O(1)時間對Array的資料做存取。 較Linked list為節省記憶體空間：因為Linked list需要多一個pointer來記錄下一個節點的記憶體位置。 Cons
新增/刪除資料很麻煩：若要在第一個位置新增資料，就需要O(N)時間把矩陣中所有元素往後移動。同理，若要刪除第一個位置的資料，也需要O(N)時間把矩陣中剩餘的元素往前移動。 若資料數量時常在改變，要時常調整矩陣的大小，會花費O(N)的時間在搬動資料(把資料從舊的矩陣移動到新的矩陣)。 適用時機
希望能夠快速存取資料。 已知欲處理的資料數量，便能確認矩陣的大小。 要求記憶體空間的使用越少越好。 Linked List Pros
新增/刪除資料較Array簡單，只要對O(1)個節點調整pointer即可，不需要如同Array般搬動其餘元素。 Linked list的資料數量可以是動態的，不像Array會有resize的問題。 Cons
因為Linked list沒有index，若要找到特定節點，需要從頭(Node *first)開始找起，搜尋的時間複雜度為O(N)。 需要額外的記憶體空間來儲存pointer。 適用時機
無法預期資料數量時，使用Linked list就沒有resize的問題。 需要頻繁地新增/刪除資料時。 不需要快速查詢資料。 用 class 實作 #include &amp;lt;bits/stdc++.h&amp;gt; using std::cout; using std::endl; class Linkedlist; class Node{ private: int data; Node *next; public: Node():data(0),next(0){}; Node(int x):data(x),next(0){}; friend class LinkedList; }; class LinkedList{ private: Node *first; public: LinkedList():first(0){}; void printlist(); void push_front(int x); void push_back(int x); void erase(int x); void clear(); void reverse(); }; void LinkedList::printlist(){ if(first==0){ cout&amp;lt;&amp;lt;&amp;#34;List is empty.</description></item></channel></rss>