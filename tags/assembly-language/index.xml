<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Assembly Language on Yuto's notes</title><link>https://example.org/tags/assembly-language/</link><description>Recent content in Assembly Language on Yuto's notes</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>2023 © [Yuto](https://joeroe.io)</copyright><lastBuildDate>Sat, 05 Nov 2022 23:13:30 +0000</lastBuildDate><atom:link href="https://example.org/tags/assembly-language/index.xml" rel="self" type="application/rss+xml"/><item><title>用 C++ 模擬簡單的 8-bit cpu</title><link>https://example.org/posts/csie/simple-8bit-cpu/</link><pubDate>Sat, 05 Nov 2022 23:13:30 +0000</pubDate><guid>https://example.org/posts/csie/simple-8bit-cpu/</guid><description>最近在看 beneater 的 8-bit cpu 想說用 C++ 寫看看練練手，所以就寫出來啦~ 由於還沒對 CPU 理解得很徹底，只有把ALU做出來而已，以後再看看會不會在重寫一個哈哈。
架構 accumulator register b register instruction register program counter 程式碼 #include&amp;lt;bits/stdc++.h&amp;gt; #include&amp;lt;stdio.h&amp;gt; using byte=uint8_t; byte accumulator; // accumulator register byte b; // register b byte instruction; // instruction register byte counter; // program counter bool negitive; // negitive flag bool sign; // sign flag bool HLT=0; byte memory[256]={0b11110000}; bool isDebug=0; void reset(){ accumulator=0; b=0; counter=0; instruction=0; for(int i=0;i&amp;lt;256;i++) memory[i]=0b11110000; } void fetch(){ if(HLT) return; instruction=memory[counter]; counter+=1; } void STA(){ if(isDebug) printf(&amp;#34;%#4x STA: %#x\n&amp;#34;,counter,memory[counter]); accumulator=memory[counter]; counter+=1; } void STB(){ if(isDebug) printf(&amp;#34;%#4x STB: %#x\n&amp;#34;,counter,memory[counter]); b=memory[counter]; counter+=1; } void ADD(){ if(isDebug) printf(&amp;#34;%#4x ADD: %#x\n&amp;#34;,counter,memory[counter]); b=memory[counter]; accumulator+=b; counter+=1; } void OUT(){ if(isDebug) printf(&amp;#34;%#4x OUT\n&amp;#34;,counter); printf(&amp;#34;%#4x\n&amp;#34;,accumulator); } void decode(){ instruction/=16; if(isDebug) printf(&amp;#34;%#4x instruction: %#x\n&amp;#34;,counter-1,instruction); switch(instruction){ case 0x0001: // STA STA(); break; case 0b0010: // LDA break; case 0b0011: // STB STB(); break; case 0b0100: // LDB break; case 0b0101: // ADD ADD(); break; case 0b1101: // OUT OUT(); break; case 0b1110: // HLT if(isDebug) printf(&amp;#34;%#4x HLT\n&amp;#34;,counter); HLT=1; break; case 0b1111: // NOP if(isDebug) printf(&amp;#34;%#4x NOP\n&amp;#34;,counter); break; } } void print_register(byte reg){ for(int i=0;i&amp;lt;8;i++){ printf(&amp;#34;%u&amp;#34;,reg/128); reg*=2; } } void print_memory(byte address){ for(int i=0;i&amp;lt;8;i++){ printf(&amp;#34;%u&amp;#34;,memory[address]/128); memory[address]*=2; } } void debug(){ if(!</description></item></channel></rss>