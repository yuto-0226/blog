<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>計算機科學 on Yuto's notes</title><link>https://example.org/categories/%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A7%91%E5%AD%B8/</link><description>Recent content in 計算機科學 on Yuto's notes</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>2023 © [Yuto](https://joeroe.io)</copyright><lastBuildDate>Fri, 17 Feb 2023 14:21:43 +0000</lastBuildDate><atom:link href="https://example.org/categories/%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A7%91%E5%AD%B8/index.xml" rel="self" type="application/rss+xml"/><item><title>Git切換帳號</title><link>https://example.org/posts/csie/gitdiffacc/</link><pubDate>Fri, 17 Feb 2023 14:21:43 +0000</pubDate><guid>https://example.org/posts/csie/gitdiffacc/</guid><description>到 控制台/使用者帳戶/認證管理員/Windows 認證 刪除GitHub的認證之後再重登即可</description></item><item><title>用 C++ 模擬簡單的 8-bit cpu</title><link>https://example.org/posts/csie/simple-8bit-cpu/</link><pubDate>Sat, 05 Nov 2022 23:13:30 +0000</pubDate><guid>https://example.org/posts/csie/simple-8bit-cpu/</guid><description>最近在看 beneater 的 8-bit cpu 想說用 C++ 寫看看練練手，所以就寫出來啦~ 由於還沒對 CPU 理解得很徹底，只有把ALU做出來而已，以後再看看會不會在重寫一個哈哈。
架構 accumulator register b register instruction register program counter 程式碼 #include&amp;lt;bits/stdc++.h&amp;gt; #include&amp;lt;stdio.h&amp;gt; using byte=uint8_t; byte accumulator; // accumulator register byte b; // register b byte instruction; // instruction register byte counter; // program counter bool negitive; // negitive flag bool sign; // sign flag bool HLT=0; byte memory[256]={0b11110000}; bool isDebug=0; void reset(){ accumulator=0; b=0; counter=0; instruction=0; for(int i=0;i&amp;lt;256;i++) memory[i]=0b11110000; } void fetch(){ if(HLT) return; instruction=memory[counter]; counter+=1; } void STA(){ if(isDebug) printf(&amp;#34;%#4x STA: %#x\n&amp;#34;,counter,memory[counter]); accumulator=memory[counter]; counter+=1; } void STB(){ if(isDebug) printf(&amp;#34;%#4x STB: %#x\n&amp;#34;,counter,memory[counter]); b=memory[counter]; counter+=1; } void ADD(){ if(isDebug) printf(&amp;#34;%#4x ADD: %#x\n&amp;#34;,counter,memory[counter]); b=memory[counter]; accumulator+=b; counter+=1; } void OUT(){ if(isDebug) printf(&amp;#34;%#4x OUT\n&amp;#34;,counter); printf(&amp;#34;%#4x\n&amp;#34;,accumulator); } void decode(){ instruction/=16; if(isDebug) printf(&amp;#34;%#4x instruction: %#x\n&amp;#34;,counter-1,instruction); switch(instruction){ case 0x0001: // STA STA(); break; case 0b0010: // LDA break; case 0b0011: // STB STB(); break; case 0b0100: // LDB break; case 0b0101: // ADD ADD(); break; case 0b1101: // OUT OUT(); break; case 0b1110: // HLT if(isDebug) printf(&amp;#34;%#4x HLT\n&amp;#34;,counter); HLT=1; break; case 0b1111: // NOP if(isDebug) printf(&amp;#34;%#4x NOP\n&amp;#34;,counter); break; } } void print_register(byte reg){ for(int i=0;i&amp;lt;8;i++){ printf(&amp;#34;%u&amp;#34;,reg/128); reg*=2; } } void print_memory(byte address){ for(int i=0;i&amp;lt;8;i++){ printf(&amp;#34;%u&amp;#34;,memory[address]/128); memory[address]*=2; } } void debug(){ if(!</description></item><item><title>組合語言開發環境設定</title><link>https://example.org/posts/csie/asm-dev-seting/</link><pubDate>Mon, 10 Oct 2022 22:09:59 +0000</pubDate><guid>https://example.org/posts/csie/asm-dev-seting/</guid><description>之前曾經嘗試在Windows上學寫組合語言，得到的回饋只有滿滿的問號。編譯過程出現了很多跟在Linux上不同的例外，這更證明了學習程式語言不難，難的是設定開發環境。 山不轉路轉路不轉人轉，我們直接用WSL上的環境去開發，就可以直接省去很多只會阻饒你學習的問題。而關於Windows Terminal和WSL的安裝可以參考Before the Course
編譯工具 回歸正題，編譯組合語言會需要兩個程式: nasm、ld。nasm是用來把.asm檔轉成.o檔，而ld則是再把.o轉成可以執行的檔案。
更新 apt 安裝套件前要把apt更新上去，不然有機會會找不到東西安裝冏事發生(本人我還真的卡了一下)
sudo apt-get update sudo apt upgrade nasm 其實安裝NASM很簡單，直接用Ubuntu內建的套件管理包安裝就行了。
sudo apt install nasm ld ld的話在GCC裡面有內建，所以如果要裝的話要裝GCC，也就是編譯C/C++的工具。
sudo apt install nasm</description></item></channel></rss>