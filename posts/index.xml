<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Yuto's notes</title><link>https://example.org/posts/</link><description>Recent content in Posts on Yuto's notes</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>2023 © [Yuto](https://joeroe.io)</copyright><lastBuildDate>Sun, 06 Aug 2023 14:51:43 +0000</lastBuildDate><atom:link href="https://example.org/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>OpenCV 使用前置攝影機</title><link>https://example.org/posts/opencv-camera/</link><pubDate>Sun, 06 Aug 2023 14:51:43 +0000</pubDate><guid>https://example.org/posts/opencv-camera/</guid><description>import cv2 as cv cam = cv.VideoCapture(0) while True: ret, frame = cam.read() cv.imshow(&amp;#39;cam&amp;#39;,frame) if cv.waitKey(1)==ord(&amp;#39;q&amp;#39;): break cam.release() cv.destroyAllWindows()</description></item><item><title>拖延大師的腦子在想什麼 | TED</title><link>https://example.org/posts/inside-the-mind-of-a-masterprocrastinator/</link><pubDate>Fri, 17 Feb 2023 14:38:35 +0000</pubDate><guid>https://example.org/posts/inside-the-mind-of-a-masterprocrastinator/</guid><description>https://www.youtube.com/watch?v=k8YEUiz7uQg</description></item><item><title>Git切換帳號</title><link>https://example.org/posts/csie/gitdiffacc/</link><pubDate>Fri, 17 Feb 2023 14:21:43 +0000</pubDate><guid>https://example.org/posts/csie/gitdiffacc/</guid><description>到 控制台/使用者帳戶/認證管理員/Windows 認證 刪除GitHub的認證之後再重登即可</description></item><item><title>相掛かり(基本型)</title><link>https://example.org/posts/shogi/aigakari/</link><pubDate>Wed, 11 Jan 2023 17:21:34 +0000</pubDate><guid>https://example.org/posts/shogi/aigakari/</guid><description>基本型 ▲２六歩 △８四歩 ▲２五歩 △８五歩 ▲７八金 △３二金 ▲２四歩 △同　歩 ▲同　飛 △２三歩
{%img https://shogipic.jp/v/ax@3x.png 360 270%}</description></item><item><title>C語言rand()函式的用法</title><link>https://example.org/posts/csie/c-rand/</link><pubDate>Mon, 21 Nov 2022 23:09:10 +0000</pubDate><guid>https://example.org/posts/csie/c-rand/</guid><description>stdlib.h rand() int rand(void); 產生介於0~RAND_MAX(=32767)之間的隨機亂數，需要透過srand()來初始化
srand() void srand(unsigned int seed); 透過傳進來的seed初始化rand()，seed若不改變則每次所產生的亂數皆會相同。
time.h time() time_t time(time_t* timer); time(NULL)會回傳自1970年午夜到現在所經過的秒數，可以用作srand的seed，每次執行的seed皆會不一樣
rand() scaled and shifted int scale_rand(int start,int end) return start+rand()%end;</description></item><item><title>Latex 編譯時缺少 .sty 檔案</title><link>https://example.org/posts/latex-packge-missing/</link><pubDate>Mon, 21 Nov 2022 01:04:43 +0000</pubDate><guid>https://example.org/posts/latex-packge-missing/</guid><description>用 CTAN 單獨把遺失的檔案載回來，整個資料夾放回 C:\texlive\&amp;lt;年分&amp;gt;\texmf-dist\tex\latex，然後在 Terminal 裡面 :
texhash</description></item><item><title>0.教材說明與預備知識</title><link>https://example.org/posts/csie/ap325/0/</link><pubDate>Fri, 18 Nov 2022 20:57:16 +0000</pubDate><guid>https://example.org/posts/csie/ap325/0/</guid><description>0.2.1 基本C++模板與輸入輸出 #include &amp;lt;bits/stdc++.h&amp;gt; // 萬用標頭檔 using namespace std; int main(){ ios::sync_with_stdio(0); // 優化cin的東西 cin.tie(0); // code here return 0; } 有優化cin的那兩行就不能再把cin/cout與scanf/printf混用，不然會發生無法預測的錯誤
使用scanf/printf 使用cin/cout並優化 0.2.2 程式測試與測試資料 stdin: 標準輸入裝置，預設鍵盤 stdout: 標準輸出裝置，預設螢幕 stderr: 標準錯誤紀錄裝置，預設螢幕 unix環境下的IO重導:
./a.out &amp;lt;test.in &amp;gt;test.out 程式裡面I/O重導:
freopen(&amp;#34;test.in&amp;#34;,&amp;#34;r&amp;#34;,stdin); freopen(&amp;#34;test.out&amp;#34;,&amp;#34;w&amp;#34;,stdout); unix環境下計時:
time a.out &amp;lt;test.in 程式裡面計時:
#include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; int main(){ clock_t start,end; start=clock(); // code here end=clock(); fprint(stderr,&amp;#34;time from start to end = %f sec.\n&amp;#34;,(float)(end-start)/CLOCKS_PER_SEC); return 0; } 0.2.3 複雜度估算 複雜度估算方式 時間複雜度通常以$O(f(n))$來表示，念作big-O，以n來表示資料量，常數倍通常忽略不計 常見的有:$O(n)$、$O(nlog(n))$、$(n^2)$</description></item><item><title>[C++]線段樹</title><link>https://example.org/posts/csie/dsa/segment-tree/</link><pubDate>Sun, 13 Nov 2022 20:21:16 +0000</pubDate><guid>https://example.org/posts/csie/dsa/segment-tree/</guid><description>程式碼 #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; class Node{ public: int start; int end; int max; int min; int sum; Node *left=nullptr; Node *right=nullptr; Node(int start,int end,int max,int min,int sum,Node *left=nullptr,Node *right=nullptr): start(start),end(end),max(max),min(min),sum(sum),left(left),right(right){} }; Node *build(int start,int end,int val[]){ if(start==end){ //cout&amp;lt;&amp;lt;&amp;#34;build: [&amp;#34;&amp;lt;&amp;lt;start&amp;lt;&amp;lt;&amp;#34;, &amp;#34;&amp;lt;&amp;lt;end&amp;lt;&amp;lt;&amp;#34;] node-&amp;gt;,max,min,sum=&amp;#34;&amp;lt;&amp;lt;val[start]&amp;lt;&amp;lt;&amp;#34;\n&amp;#34;; return new Node(start,end,val[start],val[start],val[start],nullptr,nullptr); } int mid=(start+end)/2; Node *left=build(start,mid,val); Node *right=build(mid+1,end,val); //cout&amp;lt;&amp;lt;&amp;#34;build: [&amp;#34;&amp;lt;&amp;lt;start&amp;lt;&amp;lt;&amp;#34;, &amp;#34;&amp;lt;&amp;lt;end&amp;lt;&amp;lt;&amp;#34;]&amp;#34;&amp;lt;&amp;lt;&amp;#34; node-&amp;gt;max=&amp;#34;&amp;lt;&amp;lt;max(left-&amp;gt;max,right-&amp;gt;max)&amp;lt;&amp;lt;&amp;#34; node-&amp;gt;min=&amp;#34;&amp;lt;&amp;lt;min(left-&amp;gt;min,right-&amp;gt;min)&amp;lt;&amp;lt;&amp;#34; node-&amp;gt;sum=&amp;#34;&amp;lt;&amp;lt;left-&amp;gt;sum+right-&amp;gt;sum&amp;lt;&amp;lt;&amp;#34;\n&amp;#34;; return new Node(start,end,max(left-&amp;gt;max,right-&amp;gt;max),min(left-&amp;gt;min,right-&amp;gt;min),left-&amp;gt;sum+right-&amp;gt;sum,left,right); } int query_sum(Node *root,int i,int j){ int sum=0; //cout&amp;lt;&amp;lt;&amp;#34;query: [&amp;#34;&amp;lt;&amp;lt;i&amp;lt;&amp;lt;&amp;#34;, &amp;#34;&amp;lt;&amp;lt;j&amp;lt;&amp;lt;&amp;#34;] @ [&amp;#34;&amp;lt;&amp;lt;root-&amp;gt;start&amp;lt;&amp;lt;&amp;#34;, &amp;#34;&amp;lt;&amp;lt;root-&amp;gt;end&amp;lt;&amp;lt;&amp;#34;] root-&amp;gt;sum=&amp;#34;&amp;lt;&amp;lt;root-&amp;gt;sum&amp;lt;&amp;lt;&amp;#34;\n&amp;#34;; if(root-&amp;gt;start==root-&amp;gt;end) return root-&amp;gt;sum; if(root-&amp;gt;start==i&amp;amp;&amp;amp;root-&amp;gt;end==j) return root-&amp;gt;sum; int mid=root-&amp;gt;start+(root-&amp;gt;end-root-&amp;gt;start)/2; if(j&amp;lt;=mid) return query_sum(root-&amp;gt;left,i,j); else if(i&amp;gt;mid) return query_sum(root-&amp;gt;right,i,j); else return query_sum(root-&amp;gt;left,i,mid)+query_sum(root-&amp;gt;right,mid+1,j); } int query_max(Node *root,int i,int j){ int sum=0; //cout&amp;lt;&amp;lt;&amp;#34;query: [&amp;#34;&amp;lt;&amp;lt;i&amp;lt;&amp;lt;&amp;#34;, &amp;#34;&amp;lt;&amp;lt;j&amp;lt;&amp;lt;&amp;#34;] @ [&amp;#34;&amp;lt;&amp;lt;root-&amp;gt;start&amp;lt;&amp;lt;&amp;#34;, &amp;#34;&amp;lt;&amp;lt;root-&amp;gt;end&amp;lt;&amp;lt;&amp;#34;] root-&amp;gt;max=&amp;#34;&amp;lt;&amp;lt;root-&amp;gt;max&amp;lt;&amp;lt;&amp;#34;\n&amp;#34;; if(root-&amp;gt;start==root-&amp;gt;end) return root-&amp;gt;max; if(root-&amp;gt;start==i&amp;amp;&amp;amp;root-&amp;gt;end==j) return root-&amp;gt;max; int mid=root-&amp;gt;start+(root-&amp;gt;end-root-&amp;gt;start)/2; if(j&amp;lt;=mid) return query_max(root-&amp;gt;left,i,j); else if(i&amp;gt;mid) return query_max(root-&amp;gt;right,i,j); else return max(query_max(root-&amp;gt;left,i,mid),query_max(root-&amp;gt;right,mid+1,j)); } int query_min(Node *root,int i,int j){ int sum=0; //cout&amp;lt;&amp;lt;&amp;#34;query: [&amp;#34;&amp;lt;&amp;lt;i&amp;lt;&amp;lt;&amp;#34;, &amp;#34;&amp;lt;&amp;lt;j&amp;lt;&amp;lt;&amp;#34;] @ [&amp;#34;&amp;lt;&amp;lt;root-&amp;gt;start&amp;lt;&amp;lt;&amp;#34;, &amp;#34;&amp;lt;&amp;lt;root-&amp;gt;end&amp;lt;&amp;lt;&amp;#34;] root-&amp;gt;min=&amp;#34;&amp;lt;&amp;lt;root-&amp;gt;min&amp;lt;&amp;lt;&amp;#34;\n&amp;#34;; if(root-&amp;gt;start==root-&amp;gt;end) return root-&amp;gt;min; if(root-&amp;gt;start==i&amp;amp;&amp;amp;root-&amp;gt;end==j) return root-&amp;gt;min; int mid=root-&amp;gt;start+(root-&amp;gt;end-root-&amp;gt;start)/2; if(j&amp;lt;=mid) return query_min(root-&amp;gt;left,i,j); else if(i&amp;gt;mid) return query_min(root-&amp;gt;right,i,j); else return min(query_min(root-&amp;gt;left,i,mid),query_min(root-&amp;gt;right,mid+1,j)); }</description></item><item><title>用 C++ 模擬簡單的 8-bit cpu</title><link>https://example.org/posts/csie/simple-8bit-cpu/</link><pubDate>Sat, 05 Nov 2022 23:13:30 +0000</pubDate><guid>https://example.org/posts/csie/simple-8bit-cpu/</guid><description>最近在看 beneater 的 8-bit cpu 想說用 C++ 寫看看練練手，所以就寫出來啦~ 由於還沒對 CPU 理解得很徹底，只有把ALU做出來而已，以後再看看會不會在重寫一個哈哈。
架構 accumulator register b register instruction register program counter 程式碼 #include&amp;lt;bits/stdc++.h&amp;gt; #include&amp;lt;stdio.h&amp;gt; using byte=uint8_t; byte accumulator; // accumulator register byte b; // register b byte instruction; // instruction register byte counter; // program counter bool negitive; // negitive flag bool sign; // sign flag bool HLT=0; byte memory[256]={0b11110000}; bool isDebug=0; void reset(){ accumulator=0; b=0; counter=0; instruction=0; for(int i=0;i&amp;lt;256;i++) memory[i]=0b11110000; } void fetch(){ if(HLT) return; instruction=memory[counter]; counter+=1; } void STA(){ if(isDebug) printf(&amp;#34;%#4x STA: %#x\n&amp;#34;,counter,memory[counter]); accumulator=memory[counter]; counter+=1; } void STB(){ if(isDebug) printf(&amp;#34;%#4x STB: %#x\n&amp;#34;,counter,memory[counter]); b=memory[counter]; counter+=1; } void ADD(){ if(isDebug) printf(&amp;#34;%#4x ADD: %#x\n&amp;#34;,counter,memory[counter]); b=memory[counter]; accumulator+=b; counter+=1; } void OUT(){ if(isDebug) printf(&amp;#34;%#4x OUT\n&amp;#34;,counter); printf(&amp;#34;%#4x\n&amp;#34;,accumulator); } void decode(){ instruction/=16; if(isDebug) printf(&amp;#34;%#4x instruction: %#x\n&amp;#34;,counter-1,instruction); switch(instruction){ case 0x0001: // STA STA(); break; case 0b0010: // LDA break; case 0b0011: // STB STB(); break; case 0b0100: // LDB break; case 0b0101: // ADD ADD(); break; case 0b1101: // OUT OUT(); break; case 0b1110: // HLT if(isDebug) printf(&amp;#34;%#4x HLT\n&amp;#34;,counter); HLT=1; break; case 0b1111: // NOP if(isDebug) printf(&amp;#34;%#4x NOP\n&amp;#34;,counter); break; } } void print_register(byte reg){ for(int i=0;i&amp;lt;8;i++){ printf(&amp;#34;%u&amp;#34;,reg/128); reg*=2; } } void print_memory(byte address){ for(int i=0;i&amp;lt;8;i++){ printf(&amp;#34;%u&amp;#34;,memory[address]/128); memory[address]*=2; } } void debug(){ if(!</description></item><item><title>f312. 1.人力分配</title><link>https://example.org/posts/sol/zj-f312/</link><pubDate>Sat, 15 Oct 2022 11:47:18 +0000</pubDate><guid>https://example.org/posts/sol/zj-f312/</guid><description>題目 有一個公司有$n$個員工，還有兩個工廠。如果工廠一與工廠二分別有$X_1$與$X_2$個員工，兩個工廠的收益$Y_1$,$Y_2$分別會是 $$ Y_1=A_1X_1^2+B_1X_1+C_1\ Y_2=A_2X_2^2+B_2X_2+C_2 $$ 請你考慮所有分配員工的方式，找出收益最大的組合，輸出最大收益。 注意，每個員工皆需分配到其中一個工廠。
輸入格式 第一行有三個整數$A_1,B_1,C_1$ 第二行有三個整數$A_2,B_2,C_2$ 第三行有一個正整數($1&amp;lt;=n&amp;lt;=100$)
輸出格式 輸出最大收益
解題方向 暴力破解法。x1跟x2的關係會是x2=n-x1，用for迴圈把x1或x2從1代到n找最大值。
參考程式碼 [AC]{.green} (4ms, 336KB)
//ZeroJudge f312 #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; int main(){ int A1,B1,C1,A2,B2,C2,n,ans=-2147483648; cin&amp;gt;&amp;gt;A1&amp;gt;&amp;gt;B1&amp;gt;&amp;gt;C1; cin&amp;gt;&amp;gt;A2&amp;gt;&amp;gt;B2&amp;gt;&amp;gt;C2; cin&amp;gt;&amp;gt;n; for(int x1=0;x1&amp;lt;=n;x1++){ int x2=n-x1; int y1=A1*x1*x1+B1*x1+C1; int y2=A2*x2*x2+B2*x2+C2; ans=max(ans,y1+y2); } cout&amp;lt;&amp;lt;ans; return 0; }</description></item><item><title>第二十三課</title><link>https://example.org/posts/nihongo/nihhongo-gogogo/%E6%97%A5%E6%9C%AC%E8%AA%9Egogogo-23/</link><pubDate>Tue, 11 Oct 2022 19:38:00 +0000</pubDate><guid>https://example.org/posts/nihongo/nihhongo-gogogo/%E6%97%A5%E6%9C%AC%E8%AA%9Egogogo-23/</guid><description>這一課主要在講表想要的文法
Nが欲しい 「欲しい」是「い形容詞」，中文是「想要」。用「が」表示「欲しい」的對象。
📖文法：〔一人称〕はNが欲しいです
📖文法：〔二人称〕はNが欲しいですか
「欲しい」只能用於表達自己的感受，不能用在別人身上。ex.○○さんは○○が欲しいです。
📖文法：〔三人称〕はNが欲しがっています
用在別人身上的話要用「接尾語」ー「がる」去「い」加上去變成「欲しがる」【Ⅰ類】，助詞為「を」，在用「～ている」表達現在想要。
〔ます形〕たい 📖文法：〔一人称〕はN〔ます形〕たいです
📖文法：〔二人称〕はN〔ます形〕たいですか
同「~が欲しい」用於表達自己的感受，切勿用於別人。句尾變化同「い形容詞」。
「～が欲しい」 VS. 「～たい」 「～が欲しい」：後面加名詞。
「～たい」：加上具有動作性的名詞。
三人称的たい 📖文法：〔三人称〕はVたいと言っています
「〔三人称〕は～と言ます（＝某某人說）」可以用來轉述第三者的話，改成「～ています」則是強調目前or最近說的。
📖文法：〔三人称〕はVたがっています
也可以用「〔三人称〕は～たがる」表示某某人希望做，「たがる」是由「たい」變化而來屬於【Ⅰ類】。
其他文法事項 上手になりたい 例：日本語が上手になりたいです
「なる」有變成；成為之意。「上手になる」可以解釋為變得擅長。「上手だ」是屬「な形容詞」，後面接動詞時（「なる」）要轉成副詞形「上手に」。
Nになる 例：今年の冬、私は母になります 有[成為～；當～]的意思，助詞「に」接名詞後表示變化後的結果
合格する 例：日本語能力試験に合格したいです 用「に」表示合格的對象
いる 「いる」除了有[有；在]的意思外，也有[住在；待在]的意思
～までに 「～までに」[在～之前]表示時間的最後期限。接於名詞或動詞辞書形之後。</description></item><item><title>組合語言開發環境設定</title><link>https://example.org/posts/csie/asm-dev-seting/</link><pubDate>Mon, 10 Oct 2022 22:09:59 +0000</pubDate><guid>https://example.org/posts/csie/asm-dev-seting/</guid><description>之前曾經嘗試在Windows上學寫組合語言，得到的回饋只有滿滿的問號。編譯過程出現了很多跟在Linux上不同的例外，這更證明了學習程式語言不難，難的是設定開發環境。 山不轉路轉路不轉人轉，我們直接用WSL上的環境去開發，就可以直接省去很多只會阻饒你學習的問題。而關於Windows Terminal和WSL的安裝可以參考Before the Course
編譯工具 回歸正題，編譯組合語言會需要兩個程式: nasm、ld。nasm是用來把.asm檔轉成.o檔，而ld則是再把.o轉成可以執行的檔案。
更新 apt 安裝套件前要把apt更新上去，不然有機會會找不到東西安裝冏事發生(本人我還真的卡了一下)
sudo apt-get update sudo apt upgrade nasm 其實安裝NASM很簡單，直接用Ubuntu內建的套件管理包安裝就行了。
sudo apt install nasm ld ld的話在GCC裡面有內建，所以如果要裝的話要裝GCC，也就是編譯C/C++的工具。
sudo apt install nasm</description></item><item><title>射法八節</title><link>https://example.org/posts/kyudo/shahouhassetsu/</link><pubDate>Wed, 28 Sep 2022 19:04:33 +0000</pubDate><guid>https://example.org/posts/kyudo/shahouhassetsu/</guid><description>射法八節是日本弓道中基本的規則，對其熟悉是非常重要的
{足踏み^あしぶ} {胴造り^どうづく} {弓構え^ゆがま} {打起し^うちおこ} {引分け^ひきわ} {会^かい} {離れ^はな} {残心^ざんしん}</description></item><item><title>第一課</title><link>https://example.org/posts/nihongo/nihhongo-gogogo/%E6%97%A5%E6%9C%AC%E8%AA%9Egogogo-01/</link><pubDate>Tue, 27 Sep 2022 20:47:41 +0000</pubDate><guid>https://example.org/posts/nihongo/nihhongo-gogogo/%E6%97%A5%E6%9C%AC%E8%AA%9Egogogo-01/</guid><description>～は～です 私は学生です。[我是學生]{.green} [は]{.yellow}在這種句型作助詞讀作「wa」而不是「ha」，在這邊表示在前面的名詞是整句的主題 [です]{.yellow}則是表達肯定
～は～ですか</description></item><item><title>Lecture 1:Course Overview + The Shell</title><link>https://example.org/posts/csie/missing-semester/missing-semester-01/</link><pubDate>Mon, 26 Sep 2022 17:30:41 +0000</pubDate><guid>https://example.org/posts/csie/missing-semester/missing-semester-01/</guid><description>MIT的教授們所開設的課程。每堂課都有線上筆記可以參考。
The Shell 當你打開Shell，統常只會有一行字在做上方，稱作系統提示(Shell Prompt)。
[root@localhost] $ 上面有使用者名稱(user name)跟現在使用的機器名稱還有現在所在的路徑(path)。你可以在系統提示輸入指令Shell會解析指令，例如最簡單的指令便是執行一個程式且帶有引數(argument):
date Tue Sep 27 08:40:51 CST 2022 以date這隻程式來說，他會把現在的日期跟時間印在shell上。 那當然也可以使用帶有引數的程式:
echo hello hello</description></item><item><title>Before the Course</title><link>https://example.org/posts/csie/missing-semester/missing-semester-00/</link><pubDate>Mon, 26 Sep 2022 17:29:58 +0000</pubDate><guid>https://example.org/posts/csie/missing-semester/missing-semester-00/</guid><description>課程裡面所使用的環境都是類UNIX系統。如果你是Windows系統的話就要用WSL來模擬LINUX的環境，而且可能會有很多東西跟教授所講的不太一樣。接下來會用Windows 11操作。
:::warning Windows 10 版本必須是 2004 (19041.450) 以上 :::
Windows Terminal 一個可以讓你Terminal漂漂亮亮的東西 Microsoft Store的連結
Windows 功能 直接去搜尋打上Windows 功能並點開 把裡面的Windows 子系統 Linux 版跟虛擬機平台勾起來 開啟WindowsTerminal(Power Shell或命令提示字元都可以)
wsl --install 著作權 (c) Microsoft Corporation。保留擁有權利。 使用方式: wsl.exe [Argument] [Options...] [CommandLine] 用於執行 Linux 二進位檔的引數: 如果未提供任何命令列，wsl.exe 會啟動預設的殼層。 --exec, -e &amp;lt;CommandLine&amp;gt; 執行指定的命令，但不使用預設的 Linux 殼層。 -- 依原樣傳遞剩餘的命令列。 選項: --cd &amp;lt;Directory&amp;gt; 將指定的目錄設定為目前的工作目錄。 如果使用 ~，將會使用 Linux 使用者的主目錄路徑。如果該路徑的開頭 為 / 字元，將會解譯為絕對 Linux 路徑。 否則，該值必須是絕對 Windows 路徑。 --distribution, -d &amp;lt;Distro&amp;gt; 執行指定的發佈。 --user, -u &amp;lt;UserName&amp;gt; 以指定使用者的身分執行。 --system 啟動系統發佈的殼層。 用於管理 Windows 子系統 Linux 版的引數: --help 顯示使用資訊。 --install [Options] 安裝其他 Windows 子系統 Linux 版發佈。 如需有效發佈的清單，請使用 &amp;#39;wsl --list --online&amp;#39;。 選項: --distribution, -d [Argument] 依名稱下載並安裝發佈。 引數: 有效發佈名稱 (不區分大小寫)。 範例: wsl --install -d Ubuntu wsl --install --distribution Debian --set-default-version &amp;lt;Version&amp;gt; 針對新發佈變更預設安裝版本。 --shutdown 立即終止所有執行中的發佈和 WSL 2 輕量公用程式虛擬機器。 --status 顯示 Windows 子系統 Linux 版狀態。 --update [Options] 如果未指定選項，則會更新 WSL 2 核心 至最新版本。 選項: --rollback 還原至舊版 WSL 2 核心。 在 Windows 子系統 Linux 版中用於管理發佈的引數: --export &amp;lt;Distro&amp;gt; &amp;lt;FileName&amp;gt; 將發佈匯出為 tar 檔案。 檔案名稱可以是 - 以用於標準輸出。 --import &amp;lt;Distro&amp;gt; &amp;lt;InstallLocation&amp;gt; &amp;lt;FileName&amp;gt; [Options] 匯入指定的 tar 檔案作為新發佈。 檔案名稱可以是 - 以用於標準輸入。 選項: --version &amp;lt;Version&amp;gt; 指定要用於新發佈的版本。 --list, -l [Options] 列出發佈。 選項: --all 列出全部發佈，包含 正在安裝或解除安裝的發佈。 --running 只列出目前正在執行的發佈。 --quiet, -q 只顯示發佈名稱。 --verbose, -v 顯示所有發佈的詳細資訊。 --online, -o 顯示可用發佈的清單，以使用 &amp;#39;wsl --install&amp;#39; 安裝。 --set-default, -s &amp;lt;Distro&amp;gt; 將發佈設定為預設值。 --set-version &amp;lt;Distro&amp;gt; &amp;lt;Version&amp;gt; 變更所指定發佈的版本。 --terminate, -t &amp;lt;Distro&amp;gt; 終止指定的發佈。 --unregister &amp;lt;Distro&amp;gt; 取消登錄發佈並刪除根檔案系統。 --mount &amp;lt;Disk&amp;gt; 在所有 WSL2 發佈中連結並裝載實體磁碟。 選項: --bare 將磁碟連結到 WSL2，但不要裝載磁碟。 --type &amp;lt;Type&amp;gt; 裝載磁碟時要使用的檔案系統，若未指定，預設為 ext4。 --options &amp;lt;Options&amp;gt; 其他裝載選項。 --partition &amp;lt;Index&amp;gt; 要裝載之磁碟分割的索引，若未指定，預設為整個磁碟。 --unmount [Disk] 從所有 WSL2 發佈卸載並中斷連結磁碟。 若在沒有引數的情況下呼叫，即卸載並中斷連結所有磁碟。 可以用參數-l -o把所有發行版都印出來</description></item><item><title>名詞主題 ～は～です</title><link>https://example.org/posts/nihongo/nl-01/</link><pubDate>Tue, 06 Sep 2022 23:06:08 +0000</pubDate><guid>https://example.org/posts/nihongo/nl-01/</guid><description>日文句子結構可以拆成[主部]{.red}和[敘部]{.red}。 主部：一句話的[主題]{.red} 敘部：[敘述主題]{.red}的句子
{文法^ぶん・ぽう} 📖文法: {名詞^めい．し}Aは{名詞^めい．し}Bです。 「～は～です」為名詞肯定句。
例句{私^わたし}++は++{学生^がく・せい}++です++。[我是學生]{.green}
例句中的「{私^わたし}は」即為主部「{学生^がく・せい}です」是敘部。
:::info 【{助詞^じょ・し}】 助詞在日語中扮演非常重要的角色。句子中若沒有助詞的協助，單詞之間便無法產生關聯。甚至有些同樣的句子將助詞換掉，可以使整個句子的意思改變甚至無法理解。 :::
は的意思 「は」在此文法中作為++助詞++使用，讀作「[wa]{.red}」。用來表示該劇的主題為は前面的名詞。
例如說到「{東京^とう・きょう}は~」就可以知道接下來要說的都會和該句的主題{東京^とう・きょう}有關。
例句{東京^とう・きょう}++は++{日本^に・ほん}の{首都^しゅ・と}++です++。[東京是日本的首都]{.green}
です的意思 日文的文體有分「{丁寧体^てい・ねい・たい}」和「{普通体^ふ・つう・たい}」，「です」就是丁寧体，「だ」則是普通体，這兩個都屬於==斷定助動詞==，用來表示句子的結束。
例句あなたが{好^す}き++だ++。＝あなたが{好^す}き++です++。[我喜歡你。]{.green}
{丁寧体^てい・ねい・たい}/{普通体^ふ・つう・たい} 「{丁寧体^てい・ねい・たい}」又稱「禮貌體」，是對長輩上司或不熟的人所使用的文體，雖然說是敬體，但本身==並無尊敬之意==，只有禮貌、客氣的意思。反過來則是「{普通体^ふ・つう・たい}」，是對晚輩下屬或熟識的人所使用的文體。以上又可稱為「{敬体^けい・たい}／{常体^じょう・たい}」。
非過去式 # 丁寧体 普通体 肯 {私^わたし}は{学生^がく・せい}[です]{.yellow}。 {私^わたし}は{学生^がく・せい}[だ]{.yellow}。 否 {私^わたし}は{先生^せんせい}[ではありません]{.yellow}。 {私^わたし}は{先生^せんせい}[ではない]{.yellow}。 過去式 # 丁寧体 普通体 肯 {昨日^き・のう}は{月曜日^げつ・よう・び}[でした]{.yellow}。 {昨日^き・のう}は{月曜日^げつ・よう・び}[だった]{.yellow}。 否 {昨日^き・のう}は{火曜日^か・よう・び}[ではありませんでした]{.yellow}。 昨日は{火曜日^か・よう・び}[ではなかった]{.yellow}。 :::warning 【注意】 名詞的否定用法有四種表現，意思皆相同，如下： 丁寧體：ではありません = じゃありません = ではないです = じゃないです 普通體：ではない = じゃない （越右邊&amp;raquo;越口語。）正式、鄭重&amp;raquo;口語、隨意 :::
否定用法 丁寧体在 丁嚀体過去 普通体現在 普通体過去 ではありません ではありませんでした ではない ではなかった じゃありません じゃありませんでした じゃない じゃなかった ではないです ではなかったです じゃないです じゃなかったです :::warning 寫作時要注意文體一致性，一般而言有傳達對象會使用丁寧体，無傳達對象則使用普通体。不論使用哪種文体，[一旦使用了全篇就要統一使用該文体]{.</description></item><item><title>[C++]感知機 PLA</title><link>https://example.org/posts/csie/dsa/perceptron/</link><pubDate>Thu, 12 May 2022 14:20:28 +0000</pubDate><guid>https://example.org/posts/csie/dsa/perceptron/</guid><description>感知機 PLA 針對線性資料的分類 訓練後 函式&amp;amp;變數 dot()，將兩向量(double)內積並回傳其值(double)。 double dot(std::vector&amp;lt;double&amp;gt; vec_1, std::vector&amp;lt;double&amp;gt; vec_2); vec_to_str()，將向量轉換成 string 並回傳。 std::string vec_to_str(std::vector&amp;lt;double&amp;gt; vec); intput_data()，輸入一組資料(輸入向量&amp;amp;類型) train_data intput_data(int dimension); class train_data class train_data{ private: std::vector&amp;lt;double&amp;gt; inputs; bool is_type; public: train_data(std::vector&amp;lt;double&amp;gt; inputs, bool is_type); std::vector&amp;lt;double&amp;gt; get_intputs(); bool get_type(); std::string to_str(); }; private 輸入層向量。 std::vector&amp;lt;double&amp;gt; inputs; 類型。 bool is_type; public 建構元，直接初始化輸入向量和類型。 train_data(std::vector&amp;lt;double&amp;gt; inputs, bool is_type); get_intputs()，回傳輸入層向量。 std::vector&amp;lt;double&amp;gt; get_intputs(); get_type()，回傳類型。 bool get_type(); to_str()，將 train_data 物件的輸入向量、類型轉換成字串回傳。 std::string to_str(); class perceptron class perceptron{ private: std::vector&amp;lt;train_data&amp;gt; data; std::vector&amp;lt;double&amp;gt; weights; double bias; double learning_rate; void init_weights(); void init_bias(); double cost(train_data data); void update(train_data data); void train_epoch(); public: perceptron(std::vector&amp;lt;train_data&amp;gt; data, double learning_rate); bool predict_type(train_data data); void train(int epochs,bool reset); std::string to_str(); }; private data，訓練資料陣列。 std::vector&amp;lt;train_data&amp;gt; data; weights，權重向量。 std::vector&amp;lt;double&amp;gt; weights; bias，偏置值(閥值)。 double bias; learning_rate，學習率。 double learning_rate; init_weights()，初始化權重向量。 void init_weights(); init_bias，初始化偏置值。 void init_bias(); cost()，回傳 cost double cost(train_data data); update()，更新權重。 void update(train_data data); train_epoch()，訓練完一組資料。 void train_epoch(); public 建構元，設定輸入向量陣列、學習率。 perceptron(std::vector&amp;lt;train_data&amp;gt; data, double learning_rate); predict_type()，感知姬預測的類型 bool predict_type(train_data data); train()，訓練感知機。 void train(int epochs,bool reset); to_str()，把權重、偏置值及學習率轉換成字串後回傳。 std::string to_str(); 預設資料集 int main(){ std::vector&amp;lt;train_data&amp;gt; data; int n_data=20; int n_dimension=0; double learning_rate=0; double n_correct=0; int n_epoch=0; clock_t start,end; for(size_t i=0;i&amp;lt;n_data;i++){ data.</description></item><item><title>[C++]BIT 樹狀樹組</title><link>https://example.org/posts/csie/dsa/bit/</link><pubDate>Fri, 01 Apr 2022 11:52:00 +0000</pubDate><guid>https://example.org/posts/csie/dsa/bit/</guid><description>BIT A Fenwick tree or binary indexed tree is a data structure that can efficiently update elements and calculate prefix sums in a table of numbers. -wiki
樹狀數組也稱作 Fenwick Tree 或 Binary Indexed Tree(BIT)，用來儲存資料，且可以快速求出前綴和或區間加總。對於一個長度 n 的陣列，可以在 O(n) 的時間初始化，在 O(n) 時間詢問一個前綴的訊息例如前綴和，以及在 O(n) 的時間修改其中一個值。但是 BIT 的缺點就是有些問題無法轉為前綴間的運算，無法個別操作元素。
由上面這張圖可了解 BIT 儲存的區間。Index[] 為儲存資料的陣列，BIT[] 為實際上儲存的區間。
通常一個數狀數組會有 3 個函式:
uptade(idx,delta): 將 delta 加到 idx 的節點上 query(index): 查詢從第一個位置到 idx 的所有節點的加總 range_query(idx_this,idx_that): 查詢從 idx_this 到 idx_that 間所有節點的總和 lowbit() lowbit 是為了求一個二進位數中最低位1的值(最靠近右邊的 1 的值)，構成 BIT 的核心</description></item><item><title>[LeetCode] 69. Sqrt(x)(C++)</title><link>https://example.org/posts/sol/sqrtx/</link><pubDate>Fri, 04 Mar 2022 19:50:42 +0000</pubDate><guid>https://example.org/posts/sol/sqrtx/</guid><description>題目 Given a non-negative integer x, compute and return the square root of x.
Since the return type is an integer, the decimal digits are truncated, and only the integer part of the result is returned.
Note: You are not allowed to use any built-in exponent function or operator, such as pow(x, 0.5) or x ** 0.5.
Example 1:
Input: x = 4 Output: 2 Example 2:
Input: x = 8 Output: 2 Explanation: The square root of 8 is 2.</description></item><item><title>[LeetCode] 1. Two-Sum(C++)</title><link>https://example.org/posts/sol/two-sum/</link><pubDate>Fri, 04 Mar 2022 19:32:42 +0000</pubDate><guid>https://example.org/posts/sol/two-sum/</guid><description>題目 Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.
You may assume that each input would have exactly one solution, and you may not use the same element twice.
You can return the answer in any order.
Example 1:
Input: nums = [2,7,11,15], target = 9 Output: [0,1] Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].</description></item><item><title>[C++]泛洪演算法 Flood Fill Alogrithm</title><link>https://example.org/posts/csie/dsa/floodfill/</link><pubDate>Sat, 05 Feb 2022 14:29:02 +0000</pubDate><guid>https://example.org/posts/csie/dsa/floodfill/</guid><description>簡介 Flood Fill 演算法是從一個區域中提取若干個連通的點與其他相鄰區域區分開(或分別染成不同顏色)的經典演算法(Algorithm)。因為其思路類似洪水從一個區域擴散到所有能到達的區域而得名。
實作方法 深度優先搜尋(Depth-First Search,DFS) 廣度優先搜尋(Breadth-First Search,BFS) BFS 實作 把最外面的點加入佇列(Queue)裡面，分別按照佇列中的點染色
// title: flood fill algorithm // date: 2/1 // author: 羅崧瑋 #include&amp;lt;bits/stdc++.h&amp;gt; #include&amp;lt;unistd.h&amp;gt; // terminal color font using namespace std; // matrix size #define row 10 #define col 10 // 上,下,左,右 int nx[4]={0,1,0,-1}; int ny[4]={1,0,-1,0}; // pair type typedef struct pair{ int x; int y; }pair_t; void printa(int a[row][col]); // (i,j) 起始位置 void floodfill(int a[row][col],int i,int j,int newc){ // 染色佇列 queue&amp;lt;pair_t&amp;gt; pos; pos.</description></item><item><title>向量 Vector(STL)</title><link>https://example.org/posts/csie/c++/cpp-vector/</link><pubDate>Wed, 05 Jan 2022 20:24:37 +0000</pubDate><guid>https://example.org/posts/csie/c++/cpp-vector/</guid><description>前言 在學寫C++的過程當中，從 Array 到 Vector 一直是很難跨越的障礙， 因為我的物件導向和指標不是學的很完善，導致會有點看不懂程式碼在做什麼， 所以這次我透過邊實作邊學習的方式來盡量彌補我知識上的不足， 順便做個筆記來記錄。
簡介 Vector 是 C++ 標準程式庫中的一個 class，可視為會自動擴展容量的陣列， 是C++標準程式庫中的眾多容器(container)之一，以循序(Sequential)的方式維護變數集合， 使用前預先 #include &amp;lt;vector&amp;gt; 即可。
特色 支援隨機存取 集合尾端增刪元素很快 : 常數時間 O(1) 集合中間增刪元素比較費時 : 線性時間 O(n) 以模板(泛型)方式實現，可以儲存任意類型的變數，包括使用者自定義的資料型態。 成員函式 vector 類別是以容器(Container)模式為基準設計的，也就是說，基本上它有 begin()、end()、size()、max_size()、empty() 以及 swap() 這幾個方法。
存取元素的方法 v[i] : 存取索引值為 i 的元素值 (索引值從零起算，故第一個元素是v[0]。) v.at(i) : 存取索引值為 i 的元素的值 v.front() : 回傳 vector 第一個元素的值 v.back() : 回傳 vector 最尾端元素的值 用 operator [] 可能會 Segmentation Fault。以 at() 存取會做陣列邊界檢查，如果存取越界將會拋出一個例外，這是與 operator [] 的唯一差異。撰寫較嚴肅、安全性較高的程式時使用 at()。</description></item><item><title>[C++]鏈接串列 Linked List</title><link>https://example.org/posts/csie/dsa/cpp-linkedlist/</link><pubDate>Sat, 01 Jan 2022 21:00:11 +0000</pubDate><guid>https://example.org/posts/csie/dsa/cpp-linkedlist/</guid><description>簡介 何謂鏈接串列(Linked List)?串列是一種常見的資料結構， 使用節點儲存資料，且透過接點的指標指向下一個節點， 形成一串記憶體位置不相連的資料串。
Linked List vs Array Array Pros
random access：只要利用index即可在O(1)時間對Array的資料做存取。 較Linked list為節省記憶體空間：因為Linked list需要多一個pointer來記錄下一個節點的記憶體位置。 Cons
新增/刪除資料很麻煩：若要在第一個位置新增資料，就需要O(N)時間把矩陣中所有元素往後移動。同理，若要刪除第一個位置的資料，也需要O(N)時間把矩陣中剩餘的元素往前移動。 若資料數量時常在改變，要時常調整矩陣的大小，會花費O(N)的時間在搬動資料(把資料從舊的矩陣移動到新的矩陣)。 適用時機
希望能夠快速存取資料。 已知欲處理的資料數量，便能確認矩陣的大小。 要求記憶體空間的使用越少越好。 Linked List Pros
新增/刪除資料較Array簡單，只要對O(1)個節點調整pointer即可，不需要如同Array般搬動其餘元素。 Linked list的資料數量可以是動態的，不像Array會有resize的問題。 Cons
因為Linked list沒有index，若要找到特定節點，需要從頭(Node *first)開始找起，搜尋的時間複雜度為O(N)。 需要額外的記憶體空間來儲存pointer。 適用時機
無法預期資料數量時，使用Linked list就沒有resize的問題。 需要頻繁地新增/刪除資料時。 不需要快速查詢資料。 用 class 實作 #include &amp;lt;bits/stdc++.h&amp;gt; using std::cout; using std::endl; class Linkedlist; class Node{ private: int data; Node *next; public: Node():data(0),next(0){}; Node(int x):data(x),next(0){}; friend class LinkedList; }; class LinkedList{ private: Node *first; public: LinkedList():first(0){}; void printlist(); void push_front(int x); void push_back(int x); void erase(int x); void clear(); void reverse(); }; void LinkedList::printlist(){ if(first==0){ cout&amp;lt;&amp;lt;&amp;#34;List is empty.</description></item><item><title>b004. 一個都不能少</title><link>https://example.org/posts/sol/zj-b004/</link><pubDate>Wed, 15 Sep 2021 18:13:18 +0000</pubDate><guid>https://example.org/posts/sol/zj-b004/</guid><description>b004: 一個都不能少 題目 進德女子監獄座落於自由女中旁，是間作風開放的監獄，每到中午時間便會放風讓收容人到外面用餐。當然還是會有人逾時不歸，身為管理者的美惠，每天總是要為哪些人沒有回來而傷透腦筋。現在想請你寫一個程式，幫助美惠找出哪些人沒有回來。
輸入說明： 一開始有兩個正整數 N、M (0&amp;lt;=M&amp;lt;N&amp;lt;=20)，N 代表收容人的人數(編號從 1 到 N)，M 代表回來的人數，接下來有 M 個正整數，分別代表這 M 位已經回來的收容人編號(不用考慮編號超出範圍或其他錯誤)。
解題方向 我覺得這一題我的解法算笨 我想說直接把犯人編號當陣列的索引用 然後在回來的編號裡面放值 最後再去檢查
應該還可以再精簡一點 感覺有些程式碼有點多餘 不過我懶得改:P
範例程式碼 #include &amp;lt;iostream&amp;gt; using namespace std; int back[22]={0}; int out[22]={0}; int N,M; int is_out(int); int temp; int main() { cin&amp;gt;&amp;gt;N&amp;gt;&amp;gt;M; int outNum=N-M; for(int i=0;i&amp;lt;M;i++){ cin&amp;gt;&amp;gt;temp; back[temp]=temp; temp=0; } for(int i=1;i&amp;lt;=N;i++){ if(back[i]&amp;gt;0){ out[i]=0; continue; }else{ out[i]=i; } } for(int i=0;i&amp;lt;22;i++){ if(out[i]==0){ continue; }else{ cout&amp;lt;&amp;lt;out[i]&amp;lt;&amp;lt;&amp;#34; &amp;#34;; } } return 0; }</description></item><item><title>POPCAT 自動連點器</title><link>https://example.org/posts/project/popcat/</link><pubDate>Wed, 18 Aug 2021 19:13:26 +0000</pubDate><guid>https://example.org/posts/project/popcat/</guid><description>前言 近期Pop cat風靡全球 大家都想拿到第一名 什麼是Pop cat? 這就要從一隻可愛的貓說起
Popcat風潮來自推特上一段爆紅的貓咪影片 這隻名為Oatmeal的貓咪正在向主人Xavier撒嬌 嘴巴一開一合的 樣子非常可愛 Xavier也把Oatmeal的圖片做成gif圖 後來被他的朋友PO到Reddit論壇上 突然爆紅 被歐美網友們做成各式各樣的迷因（meme） 搭配上「POP」的音效 -數位時代。檢自https://www.bnext.com.tw/article/64440/popcat-click-competition-janis (2021/08/19)
我那時就想 一直點一直點手很酸 國外也有人用連點器 (物理) 那為什麼我不來試看看用程式寫 然後又剛好看到 Youtube 上的 Selenium 教學 剛好可以讓我寫出連點器 於是便著手編寫了
Selenium Selenium 是一個綜合性的項目，為web瀏覽器的自動化提供了各種工具和依賴包
要在 Python 中使用 Selenium 要先安裝它的套件
$ pip install selenium 然後要安裝對應的 WebDriver 才能讓它在瀏覽器上面跑 這邊就用 Chrome (網址) 記得要挑對版本下載 下載完後把他丟到程式檔案的同一個資料夾就可以了
程式碼 Github: 連結
from selenium import webdriver import time import random PATH = &amp;#34;./chromedriver.exe&amp;#34; driver = webdriver.Chrome(PATH) driver.get(&amp;#34;https://popcat.click/&amp;#34;) neko = driver.</description></item><item><title>二進位制 &amp; 邏輯閘實作</title><link>https://example.org/posts/csie/logic-gate/</link><pubDate>Wed, 16 Jun 2021 17:26:48 +0000</pubDate><guid>https://example.org/posts/csie/logic-gate/</guid><description>前言 我們都知道在 C++ 裡面 如過要實現加法的話可以寫成
int a=1; int b=2; a+b; 答案理所當然會是 3 雖然我們是用 C++ 去編寫的 但是電腦執行的卻是編譯過的機械碼 繞我不禁好奇，電腦是如何進行加法的 ? 不是透過寫程式碼讓他編譯，而是最原始的方法 單純的電子訊號，也就是 0 和 1
二進位制 5+5 ，只要有好好學過數學的人都應該會知道答案是 10 這種進位制即是大家最熟悉的 10 進位制 ，也就是當數字加到 10 時要進一位 2 進位制 也是一樣的概念，當數字加到 2 時要進一位 舉例來說 1+1 的答案就會是 10
2 進位制 廣泛被運用在電腦上面，而一個數字也被稱作位元
邏輯閘 邏輯閘是在積體電路上的基本組件。這些電晶體的組合可以使代表兩種訊號的高低電平在通過它們之後產生高電平或者低電平的訊號。高、低電平可以分別代表邏輯上的「真」與「假」或二進位當中的1和0，從而實現邏輯運算。常見的邏輯閘包括與閘，或閘，非閘，互斥或閘（也稱：互斥或）等等。(維基百科)
AND \ 1 0 1 1 0 0 0 0 OR \ 1 0 1 1 1 0 1 0 XOR \ 1 0 1 0 1 0 1 0 實作 這次的實作是參考 Ben Eater 的 Learn how computers add numbers and build a 4 bit adder circuit</description></item><item><title/><link>https://example.org/posts/sol/zj-d712/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.org/posts/sol/zj-d712/</guid><description>TLE解 用multimap的索引會排序的特性把n跟cycle(n)反著存進map裡面
//ZeroJudge d713 #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; int cycle(int n,int len){ //printf(&amp;#34;%d &amp;#34;,n); if(n==1) return len+1; if(n%2!=0) len=cycle(3*n+1,len+1); else len=cycle(n/2,len+1); return len; } int main(){ multimap&amp;lt;int,int&amp;gt; mmap; for(int i=1;i&amp;lt;100000;i++) mmap.insert(make_pair(cycle(i,0),i)); int a,b; while(scanf(&amp;#34;%d %d&amp;#34;,&amp;amp;a,&amp;amp;b)!=EOF){ //cout&amp;lt;&amp;lt;a&amp;lt;&amp;lt;&amp;#34; &amp;#34;&amp;lt;&amp;lt;b&amp;lt;&amp;lt;&amp;#34; &amp;#34;; printf(&amp;#34;%d %d &amp;#34;,a,b); if(a&amp;lt;b) swap(a,b); for(auto it=--mmap.end();it!=mmap.begin();it--){ if((*it).second&amp;lt;a &amp;amp;&amp;amp; (*it).second&amp;gt;b){ //cout&amp;lt;&amp;lt;(*it).first&amp;lt;&amp;lt;&amp;#39;\n&amp;#39;; printf(&amp;#34;%d\n&amp;#34;,(*it).first); break; } } } return 0; } 線段樹解 目前測資2沒過
//ZeroJudge d713 #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; int cycle(int n,int len){ //printf(&amp;#34;%d &amp;#34;,n); if(n==1) return len+1; if(n%2!</description></item><item><title/><link>https://example.org/posts/sol/zj-e798/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.org/posts/sol/zj-e798/</guid><description>題目 2019TOI1214 新手同好會 5. 卷積神經網路 (CNN) {試題連結}
問題敘述 卷積神經網絡 (Convolutional Neural Network) 簡稱 CNN，是現在最火紅的深度學習課程必教的模型。 CNN 在影像識別方面非常厲害，許多影像辨識的模型都是以 CNN 的架構為基礎去做延伸。 CNN 分為三個部分：卷積層 (convolution layer)、池化層 (pooling layer) 和全連接層 (fully connected layer)。 卷積層用於提取影像特徵，池化層減小資料的空間大小，全連接層主要目的為實現分類。 池化層最常見的作法是最大池化法 (max pooling)，它將輸入的影像劃分為若干個 2×2 的矩形子區域，對每個子區域輸出最大值。 給定一個 n×n 的二維陣列，請實作最大池化演算法並輸出池化後的結果。
最大池化法示意圖 圖片來源：https://embarc.org/embarc_mli/doc/build/html/MLI_kernels/pooling_max.html
輸入格式 第一行有一個正整數n（4 &amp;lt;= n &amp;lt;= 20，n為2的倍數），代表輸入影像邊長。接下去有n行，每行各有n個數字，數值範圍在正負 2^31 之間，以空白隔開，代表影像陣列中的資料值。
輸出格式 輸出經2x2 最大池化後的結果。
範例測資 輸入1 : 4 12 20 30 0 8 12 2 0 34 70 37 4 112 100 25 12 輸出1 : 20 30 112 37 輸入2 : 6 10 2 0 12 1 3 21 0 13 2 2 0 0 0 0 10 0 0 19 2 0 13 61 1 0 1 32 3 0 2 9 2 0 31 11 0 輸出2 : 21 13 3 19 13 61 9 38 11 解題方向 簡化題目後，我們可以得出題目是要我們把一個大矩陣都拆成2*2的小矩陣。然後把每個小矩陣的最大值輸出成一個新的矩陣，而這個過程被稱作池化。了解題目的要求後就簡單了，我的作法是以一個小區塊先池化，輸出後再處理下一個小區塊。</description></item></channel></rss>